
https://wandbox.org/ -> CPP IDE
https://cppinsights.io/ -> Insight of cpp
https://www.youtube.com/watch?v=bFtkHJy9kIU -> Watch for cpp interview question

"***********************************************************************************************************************************"
What is difference between in C and C++?
Why is the size of an empty class not zero in C++?
What are C++ access, specifiers ?
What are the various OOPs concepts in C++?
What are the differences between a C++ struct and C++ class ?
What is difference between new and malloc?
What is a namespace?
What is Overriding ?
How to create .dll in C++ and how to link .dll in your code?
What is overloading?
How to create and use a reference variable in c++?
Can you overload a function based only on whether a parameter is a value or a reference?
What is difference between function overloading and Operator Overloading?
Can we access private data members of a class without using a member or a friend function?
What is the use of inline function?
How to access derived class function from base class object without using virtual function?
Distinguish between shallow copy and deep copy in c++ ?
Friend class and function in C++ ?
What is difference between constructor and destructor in c++?
How are .h files loaded and linked with their .c files?
What Is Inheritance c++?
What is “this” pointer in c++?
What is difference between delete and free?
What is encapsulation?
What is static member in c++?
Can Static Functions Be Virtual in C++?
What is a pure virtual function in c++?
What is abstract classes in c++ ?
Write a code to count the number of words, characters, and lines in a file in c?
Any fundamental difference between source and header files in C?
Can a C++ class member function template be virtual?
What is the Diamond problem? How can we get around it?
What is virtual inheritance in c++ ?
What are the advantages of inheritance?
Why virtual functions cannot be static in c++?
How does the compilation/linking process work?
Can you explain the order of execution in constructor initialization list?
How to make a C++ class whose objects can only be dynamically allocated?
Is it possible to have Virtual Constructor? If yes, how? If not, Why not possible?
What is virtual dispatch mechanism ?
What is a constructor? Is default constructor exist in C++?
Can a constructor throw an exception? 
How to handle the error when the constructor fails?
What is the difference between a copy constructor and an overloaded assignment operator?
When are copy constructors called in C++?
Why copy constructor takes the parameter as a reference in C++?
What do you mean by inline function?
What is a template function?
Can we combine c and C++ code?
What is shared pointer in c++?
What is typecasting?
Why is a pure virtual function initialized by 0?
How to create multidimensional arrays using new?
When should static_cast, dynamic_cast, const_cast and reinterpret_cast be used?
Can I free() pointers allocated with new?
How do I convert an integer to a string in C++?
What is the difference between a pointer and a reference?
When should I use references, and when should I use pointers?
What is the assignment operator in c++?
What does the explicit keyword mean?
When do we need to create virtual destructor in our class?
What is Polymorphism?
What is the effect of extern “C” in C++?
What are the different types of polymorphism in C++?
Can a copy constructor accept an object of the same class as a parameter, in place of reference
of the object? If No, why not possible?
What about Virtual Destructor?
What is conversion constructor?
How do you access the static member of a class?
When do we use the Initializer List in C++?
Is it possible to overload the destructor the class?
Which is faster: Stack allocation or Heap allocation
What is auto pointer in C++?
What is the smart pointer in C++?
Can I delete pointers allocated with malloc()?
Can I use realloc() on pointers allocated via new?
Can I call the destructor explicitly?
Can one constructor of a class call another constructor of the same class to initialize the this object?
What is the difference between an array and a list?
What is a “pure virtual” member function and when it is used?
What are VTABLE and VPTR?
How to handle the exception in C++?
What is a Memory Leak?
Why static functions cannot access non-static variables?
What is a dangling pointer?
What is “mutable” keyword in C++?
What are the debugging methods you use when came across a problem?
STL Containers – What are the types of STL containers?

"***********************************************************************************************************************************"

#include<iostream>
#include<vector>
#include<stdio.h>

using namespace std;

int main()

{

/*


cout<<"*******************************Google Mission - 23-July-20202****************************"<<endl;

   int array[2] = {10, 20};

   cout<< array[-1] << "\n"
       << array[0] <<"\n"
       << array[1] <<"\n"
       << array[2] <<"\n"
       << array[3] <<"\n";

   cout<<"=========================================================="<<endl;

   int google[5];

   for (int i = 0 ; i < 5 ; i++) {

     cout <<"Address of ["<< i <<"] is: " << &google[i]<<"\n";
   }


   cout<<"=========================================================="<<endl;

  // void  alexa[]; // error: declaration of ‘alexa’ as array of void
  // Note  Array of void is not possible in c++

   void  *aws[100]; // Array of void Pointer

   int youtube[] = {100, 200, 300, 400}; // int (*)[4]

    int *android = &youtube; // error: cannot convert ‘int (*)[4]’ to ‘int*’ in initialization

   cout<<"Address of &youtube : " << &youtube <<endl;


    int *android1 = youtube;

    cout<<"Address of youtube  : " << youtube <<endl;


cout<<"=========================================================="<<endl;
*/


// Array member access using pointer arithmetics.

/*

int googlepay[] = {1 , 2 , 3 , 4 , 5 , 6};

int *gpay = googlepay;

int c;

for (c= 0 ; c < 6 ; c++) {

cout << "Array members:"<<"*(gpay + c)-> "<<*(gpay + c) << " \t "<<"googlepay[c]-> "<<googlepay[c] << "\n" ;

cout<<"=========================================================="<<endl;
}
cout<<"=========================================================="<<endl;

vector<int> googlevector;

for (int i = 0 ; i < 5 ; i++)
{

   googlevector.push_back(i);
}

cout <<"Out"<<endl;

for (auto value = googlevector.begin(); value != googlevector.end() ; value++)
{
   cout<< *value <<endl;
}

cout<<"=========================================================="<<endl;
cout<<"*******************************Google Mission - 24-July-20202****************************"<<endl;
*/




/*------------------------------------------------------
Pointer to Array:- Pointer to an array is also known as Array pointer.

We are using the pointer to access the components of the array.
-------------------

Data-type (*variable-name)[size of array];*/

/*int (*ptr)[10];

int (*ptr1)[10] = NULL; // Pointer to array of ten numbers

//Ex :-

int (*ptr2)[5];   // Pointer to interger of five numbers

int fun[5] = {1, 2, 3, 4, 5};


ptr2 = &fun;  // Point to whole array of fun

int i = 0;

for (i = 0 ; i < 5 ; i++) {

cout << "Element of the array : " << *(*ptr2 + i) <<endl;

}*/



/*
================================

Array of Pointer:- is an array of the pointer variable .
It is also know as pointer array.

Data-type *variable[size of array];


*/



/*int *ptr3[10];


int ptr5[5] = {1, 2, 3, 4, 5};

int *fun[5]; // Pointer array

int i;


for (i = 0 ; i < 5 ; i++) {

fun[i] = &ptr5[i];

}

// Printing value using Pointer


for (int i = 0 ; i < 5 ; i++) {

cout << "Print the value of array : "<< *(ptr5 +i)<<::std::endl;

}*/




/*
=====================================
 Array of pointer
*/

/*int i;

char *name[] = {
                "Mukesh",
                "RojarFast",
                "Hanuman"
};

for (int i = 0 ; i < 3 ; i++) {

cout << "Elements are :" << *(name+i) <<::std::endl;

}*/


/*
==========================

int (*Pointer-to-array)[5];

int *array-point-to-zero-location;
int array-point-to-whole-location[5];


array-point-to-zero-location = Pointer-to-array; // Points to 0th element of the arr.
    p = arr;

array-point-to-whole-location = &Pointer-to-array; // Points to the whole array arr.

*/


int arr[3][4] = {
                    {10, 11, 12, 13},
                    {20, 21, 22, 23},
                    {30, 31, 32, 33}
                  };

  int (*ptr)[4]; // Pointer to array which is called array Pointer

  ptr = arr;

  cout<< "ptr = "<< ptr << " ptr + 1 = "<< ptr + 1 << " ptr + 2 = " << ptr + 2 << "ptr +3 = " <<ptr +3 <<std::endl;

   printf("%p %p %p\n", *ptr, *(ptr + 1), *(ptr + 2));

   printf("%d %d %d\n", **ptr, *(*(ptr + 1) + 2), *(*(ptr + 2) + 3));

   printf("%d %d %d\n", ptr[0][0], ptr[1][2], ptr[2][3]);


/*===============================================================================================
***********************************************************************************************
===============================================================================================

*/



return 0;

}


"*************************************************************************************************************************************"

#include<iostream>
using namespace std;

int main()
{
/*

struct Microsoft
{

   char name;

};

cout<<"Size of Structure : " <<sizeof(Microsoft)<<endl; // 1 Byte

*/

/*
struct Microsoft1
{

   char name; // 1 byte + 3 byte structure padding
   int companyID; // 4 byte

};

cout<<"Size of Structure : " <<sizeof(Microsoft1)<<endl; // 8 Byte

*/

// How to declare structure variables?
/*A structure variable can either be declared with structure declaration or
as a separate declaration like basic types.*/

struct Microsoft2
{

   char name; // 1 byte + 3 byte structure padding
   int companyID; // 4 byte

} window;

// Here window is declared as Microsoft2




struct Microsoft3
{

   char name; // 1 byte + 3 byte structure padding
   int companyID; // 4 byte

};


struct Microsoft3 microsoft3; // microsoft3 nothing but structure variable



//How to initialize structure members?

/*
 * Structure members cannot be initialized with declaration.
 * when a datatype is declared, no memory is allocated for it.
 * Memory is allocated only when variables are created.
 * */

/*
struct Microsoft4
{

   char *name = "Mukesh";
   int companyID = 4601;

}micro4;

cout<<"Print structure value:  "<< micro4.name << " : " << micro4.companyID<<endl;
*/

/*
 * structure.cpp: In function ‘int main()’:
structure.cpp:69:17: warning: non-static data member initializers only available with -std=c++11 or -std=gnu++11 [enabled by default]
    char *name = "Mukesh";
                 ^
structure.cpp:70:20: warning: non-static data member initializers only available with -std=c++11 or -std=gnu++11 [enabled by default]
    int companyID = 4601;
                    ^
structure.cpp:69:17: warning: deprecated conversion from string constant to ‘char*’ [-Wwrite-strings]
    char *name = "Mukesh";
 *
 * */


/*
struct Microsoft5
{

   string name;
   int companyID;

};

struct Microsoft5 microsoft5 = {"Mukesh", 4601};

cout<<"Print Microsoft5 value:  "<< microsoft5.name << " : " << microsoft5.companyID<<endl;

*/



/* What is an array of structures?
 *
 * Like other primitive data types, we can create an array of structures
 *
 * */

/*
struct Google
{
   string name;
   int companyID;

};

struct Google google[10]; // Created an array of Google structure

int i;

for(i = 0; i<10; i++)
{
   google[i].name = "Rojar";
   google[i].companyID = 123;
}

for(i = 0 ; i<10; i++)
{
   cout<<"Print Google value: " << i <<" ---> "<< google[i].name << " : " << google[i].companyID<<endl;

}*/

/*
What is a structure pointer?
Like primitive types, we can have pointer to a structure.
 If we have a pointer to structure, members are accessed using arrow ( -> ) operator.
*/



struct Amazon
{
   string name;
   int companyID;

};

struct Amazon amazon = {"Mukesh", 4609};

struct Amazon *amazon2 = &amazon; // amazon2 is a pointer to structure amazon


cout<<"Print Amazon Structure value:  "<< amazon2->name << " : " << amazon2->companyID<<endl;




typedef struct structa_tag
{
   char        c; // 1 Byte
   short int   s; // 2 Byte
} structa_t;

// 4Byte = 1Byte + 1 Byte Padding + 2 Byte

cout<<"sizeof(structa_t)= " << sizeof(structa_t)<<endl;



// structure B
typedef struct structb_tag
{
   short int   s; // 2 Byte
   char        c; // 1 Byte
   int         i; // 4 Byte
} structb_t;

// 8 Byte = 2 Byte + 1 Byte + 1 Byte Padding + 4 Byte

cout<<"sizeof(structb_t)= " << sizeof(structb_t)<<endl;



// structure C
typedef struct structc_tag
{
   char        c; // 1 Byte
   double      d; // 8 Byte
   int         s; // 4 Byte
} structc_t;


// 24 Byte = 1 Byte + 7 Byte Padding + 8 Byte + 4 Byte + 4 Byte Padding

cout<<"sizeof(structc_t)= " << sizeof(structc_t)<<endl;



// structure D
typedef struct structd_tag
{
   double      d; // 8 Byte
   int         s; // 4 Byte
   char        c; // 1 Byte
} structd_t;

// 16 Byte = 8 Byte + 4 Byte + 1 Byte + 3 Byte Padding

cout<<"sizeof(structd_t)= " << sizeof(structd_t)<<endl;

return 0;

}



"************************************************************************************************************************************"
#include<iostream>
#include<stdio.h>
#include<cmath>

using namespace std;


/* Demo class */


class A
{

public:

void fun();

protected:

int value;

};

class B : public A
{

public:

void mode()
{
cout<<value<<endl;
}

};


int main()
{

B objB;
objB.mode();

}



/*// Observed the code care fully
class A
{
public:

	virtual void fun()
	{
		cout<<"Fun in class A"<<endl;
	}
	virtual ~A()
	{
		cout<<"in A class destructor"<<endl;
	}

};


class B: public A
{
public:

	void fun()
	{
		cout<<"In class B"<<endl ;
	}
	 ~B()
	{
		cout<<"in B class destructor"<<endl;
	}

};


int main()
{
	A *obj = new B();
	obj->fun();
	delete obj;
}*/



/*// Observed the code care fully
class A
{
public:

A()
{
		cout<<"In Class A()"<<endl ;
}

A(int a)
{
	cout<<"In Class A()"<<endl ;
}


};


class B
{
public:
	A objA; // Error Searching default constructor in A class
};


int main()
{
	B objB;
}*/





/*class Base
{
   private:
   int x;
   public:
   void show()
   {
      cout<<"Show"<<endl;
   }
   
};

int main()
{
   Base *ptr;
   Base &ptr1;
   Base obj;
   ptr->show();
   obj.show();
   ptr1.show() // eRROR INITIALIZE THE PTR1
   cout<<"Sizeof Base = "<<sizeof(ptr)<<endl;
   cout<<"Sizeof Base = "<<sizeof(obj)<<endl;
   cout<<"Sizeof int Pointer = "<<sizeof(int*)<<endl;
}*/


/*
// Friend function and friend class in c++
(1) Keyword "friend" is used to make some[function or class] as friend of your class.
(2) Friend function or friend class can access private/public/protected data member or member of another class
(3) Function can not become friend of another function
(4) class can not become friend of function
(5) Friendship is not a mutual. 
    If a class A is friend of B, then B doesn't become friend of A automatically.
(6) Friendship is not inherited

*/

/*
// Example of friend function
class Base
{
private:
   int x;
   
public:
   
   Base() {}
   Base(int a):x(a){}
   friend void set(Base& obj, int a);
   friend int get(Base& obj);
   
};

void set(Base& obj, int a)
{
   obj.x = a;
}


int get(Base &obj)
{
   return obj.x;
}

int main()
{
   Base obj(100);
   cout<<"Value "<< get(obj)<<endl;
   set(obj, 299);
   cout<<"Value "<< get(obj)<<endl;
   
   return 0;
}

*/


/*

class Base
{
 
private:
   int x;
public:
   Base(){}
   Base(int a):x(a){}
   friend class GetSet;
};

class GetSet
{
public:
   void set(Base& obj, int a)
   {
      obj.x= a;
   }
   
   
   int get(Base& obj)
   {
      return obj.x;
   }
};

int main()
{
   Base obj(200);
   GetSet getset;
   cout<<"Frind class ="<< getset.get(obj)<<endl;
   getset.set(obj, 300);
   cout<<"Frind class ="<< getset.get(obj)<<endl;

}
*/



/*class Cents
{
private:
   int m_cents;

public:
 Cents()
{

}
   Cents(int cents) { m_cents = cents; }

   // add Cents + int using a friend function
   friend Cents operator+(const Cents &c1, int value);

   // add int + Cents using a friend function
   friend Cents operator+(int value, const Cents &c1);


   int getCents() const { return m_cents; }
};

// note: this function is not a member function!
Cents operator+(const Cents &c1, int value)
{
   // use the Cents constructor and operator+(int, int)
   // we can access m_cents directly because this is a friend function
   return Cents(c1.m_cents + value);
}

// note: this function is not a member function!
Cents operator+(int value, const Cents &c1)
{
   // use the Cents constructor and operator+(int, int)
   // we can access m_cents directly because this is a friend function
   return Cents(c1.m_cents + value);
}

int main()
{
   Cents c1(10), c2, c3;
   Cents c1 = Cents(4) + 6;
   Cents c2 = 6 + Cents(4);

   c2 = c1 + 10;
   c3 = 20 + c1;

   std::cout << "I have " << c2.getCents() << " cents." << std::endl;
   std::cout << "I have " << c3.getCents() << " cents." << std::endl;

   return 0;
}*/




/*
class A
{
public:
 A()
{
      i = 0;
      cout<<"A Constructor i = "<< i <<endl;
}


 int operator+( int intobj, myclass myobj)
 {
    return intobj + int(myobj);
 }


   A operator + ( int rhs )
   {
     return A( i + rhs );
   }

   friend A operator + (const A& left, const A& right)
   {
      return A(left.i + right.i);
   }

   A& operator + (const A& obj)
   {
      A a;
      a.i = i + obj.i;
      cout<<"Operator overloading"<<endl;
      return *this;
   }

private:
   int i;
};

int main()
{
   A obj1, obj2, obj3;

  // obj2 = obj1 + 10;
   obj3 = 20 + obj1;

   return 0;
}
*/



/*Use of explicit keyword
#include<iostream>
using namespace std;

class Point
{
private:
    int x, y;
public:
    explicit Point(int i = 0, int j = 0) {
        x = i;   y = j;
    }
    void print() {
        cout << endl << " x = " << x << ", y = " << y;
    }
};

int main()
{
    Point t(20, 20);
    t.print();
    t = 30;   // Member x of t becomes 30
    t.print();
    return 0;
}*/



/*class Base
{
public:
	virtual void fun() const
	{
		cout<<"In BAse class"<<endl;
	}
};

class Derive:public Base
{
public:

	void fun() const
	{
		cout<<"In Derive class"<<endl;
	}
};

int main()
{

	Base *base;
	Derive derive;
	base = &derive;
	base->fun();
 cout<<"In main"<<endl;
}*/

/*Overload new and delete operator*/


/*How to restric the dynamic allocation of the object

class DynamicAllocation
{
private:

	void* operator new (size_t size){};
	void* operator new[] (size_t size){};
	void operator delete(void*){};

public:
	int x;
	DynamicAllocation(int i)
	{
		x = i;
	}
	void printValue()
	{
		cout<<"Value of A = "<<x<<endl;
	}

};


int main()
{
	//DynamicAllocation dynamicAllocation = new DynamicAllocation();
	//DynamicAllocation dynamicAllocation = new DynamicAllocation[10];
	//Dynamic memory allocation not allowed

	DynamicAllocation dynamicAllocation(100); // Compile time allocation is allowed
	dynamicAllocation.printValue();

}*/



/*
(***) Vector internal implematation


template<typename T>
class Vector
{
public:

	typedef T *Iterator;
	Vector();                                                // Default vector
	Vector(unsigned int value);                             // Parameteried Vector
	Vector(unsigned int value, const T& initial);
	Vector(const Vector<T>& obj);                         // Copy constructor
	Vector<T> & operator = (const Vector<T>& obj) ;      // Assigned ment operator
   ~Vector();                                           // Destructor

   unsigned int capacity() const;                     // Capacity of the vector
   unsigned int size() const;                        // Calculate the total size of the vector
   bool empty() const;                              // Check the vector is empty or not
   Iterator begin();                               // Take the element from the begin of vector
   Iterator end();                                // Take the element from the end of the vector
   T &front();                                   // Take first element of the vector
   T &back();                                   // Take last element of the vector
   void push_back(const T& value);             // Insert the element in the vector
   void pop_back();                           // Take the element from the vector


   void reserve(unsigned int capacity);   // reserve the size of the vector
   void resize(unsigned int size);       //  resize of the vector


   T & operator[](unsigned int index); // Take the element from the vector at perticular index

  void clear();

private:

   unsigned int _capacity;         // Hold the total capacity of the vector
   unsigned int _size;            //  Hold the size of the vector
   unsigned int Log;             //
   T* buffer;                   //  Hold the buffer
};

// Default constructor
template<typename T>
Vector<T>::Vector()
{

	_capacity = 0;
	_size     = 0;
	buffer    = 0;
	Log       = 0;
}

// Vector destructor
template<typename T>
Vector<T>::~Vector()
{
	delete[]buffer;
}
// Parametirized constructor

template<typename T>
Vector<T>::Vector(const Vector<T> &Obj)
{
	_capacity = Obj._capacity;
	_size     = Obj._size;
	Log       = Obj.Log;
	buffer = new T[_size];

	for (int index = 0 ; index < _size ; index++)
	{
		buffer[index] = Obj.buffer[index]; // Assiging the index value in the buffer
	}
}

// Parametirized constructor

template<typename T>
Vector<T>::Vector(unsigned int index)
{
	_size = index;
	Log = ceil(log((double)index) / log(2.0));
	_capacity = 1 << Log;
	buffer = new T[_capacity];
}

// Empty the Vector class size

template<typename T>
bool Vector<T>::empty() const
{
	return _size = 0;
}

// Initialized vector with some value

template<typename T>
Vector<T>::Vector(unsigned int index, const T& initialValue)
{
	_size = index;
	Log = ceil(log((double)index) / log(2.0));
	_capacity = 1 << Log;
	buffer = new T[_capacity];
	for (int value ; value < _size ; value++)
	{
		buffer[value] = initialValue;
	}

}

// Assignement copy contstructor

template<typename T> Vector<T>&
Vector<T>::operator = (const Vector<T> &obj)
{
	delete[]buffer;
	_size = obj._size;
	Log = obj.Log;
	_capacity = obj._capacity;
	buffer = new T[_capacity];
	 for (int value ; value < _size ; value++)
	 {
		 buffer[value] = obj.buffer[value];
	 }

	 return *this;
}


template<typename T> typename
Vector<T>::Iterator Vector<T>::begin()
{
return buffer;
}

template<typename T> typename
Vector<T>::Iterator Vector<T>::end()
{
	return buffer + size();
}

template<typename T> T&
Vector<T>::front()
{
 return buffer[0];
}

template<typename T> T&
Vector<T>::back()
{
	return buffer[_size - 1];
}

template<typename T> void
Vector<T>::push_back(const T& index)
{
	if (_size >= buffer)
	{
		reserve(1 << Log);
		Log++;
	}
	buffer[_size++] = index;
}

template<typename T>void
Vector<T>::pop_back()
{
return _size--;
}

// Rserve the buffer of the vector
template<typename T>void
Vector<T>::reserve(unsigned int bufferCapacity)
{
	T *newBuffer = new T[bufferCapacity];

	for (int i = 0 ; i < _size ; i++)
	{
		newBuffer[i] = buffer[i];
	}
	_capacity = bufferCapacity;
	delete[]buffer;
	buffer = newBuffer;
}

Calculate the size of the vector

template<typename T> unsigned int
Vector<T>::size() const
{
	return _size;
}

Calcute the resize the vector

template<typename T> void
Vector<T>::resize(unsigned int size)
{
	Log = ceil(log((double)size)/ log(2.0));
	reserve(1 << Log);
	_size = size;
}

Calcute the index Sbsscript operator

template<typename T>T&
Vector<T>::operator[](unsigned int index)
{
	return buffer[index];
}

Calcute the total capacity of the vector
template<typename T> unsigned int
Vector<T>::capacity()const
{
	return _capacity;
}


Clear the vector

template<typename T> void
Vector<T>::clear()
{
	_capacity = 0;
	_size = 0;
	buffer = 0 ;
	Log = 0;
}


// Main functio of the vector
int main()
{

	Vector<int> vObj;
}

*/



/*//Check indiannes of the machine

int main()
{
	unsigned int a = 1;

	char *p = (char*)(&a);

	if(*p)
	{
		cout<<"Little Indian"<<endl;
	}
	else
	{
		cout<<"Big Indian"<<endl;
	}
}*/



/*

union test {
    unsigned int x : 3;
    unsigned int y : 3;
    int z;
};

int main()
{
    union test t;
    t.x = 5;
    t.y = 4;
    t.z = 1;
    printf("t.x = %d, t.y = %d, t.z = %d",
           t.x, t.y, t.z);
    return 0;
}


#include <stdio.h>
struct test {
    unsigned int x;
    long int y : 33;
    unsigned int z;
};
int main()
{
    struct test t;
    unsigned int* ptr1 = &t.x;
    unsigned int* ptr2 = &t.z;
    printf("%d", ptr2 - ptr1);
    return 0;
}*/



/*class test 
{
   char ch;
//  / double d;
   unsigned int x;
  unsigned int y : 1;
   unsigned int z;
   char ch1;
   int ddd;
};
int main()
{
    cout<<"Value = " << sizeof(test)<<endl;
    return 0;
}*/


/*class A
{
 int a : 2;
 int b : 1;
 int c : 10;
 int d : 1;
 int e: 1;
};

class B
{
public:
	B (A a) {

		cout<<"Inside B class"<<endl;
	}

	B(int a)
	{
		cout<<"Inside B "<<endl;
	}
};

int main()
{
	cout<<"Size of A Class= "<<sizeof(A)<<endl;
	A a;
	B b = a;
	B b1 = 10;
}*/




/*
static_cast --> simplet cast and compile time cast(
it doses the think like implicit conversion)
=> It performs imlicit conversion between types.
*/


// => (1) It performs imlicit conversion between types.



/*int main()
{
   float f = 3.5;
   int a;
   a = f;
   a = static_cast<int>(f); //--> happen at compile time
}*/




// => (2) Use static_cast when conversion between types is provided through
// conversion operator or conversion constructor.



/*class Int
{
   int a;

public:
   // Conversion constructor
   Int(int i = 0): a(i)
{
      cout<<"Conversion constructor"<<endl;
}

operator string()
      {
      cout<<"Conversion operator = "<< a <<endl;
      return to_string(a);
     }
};


int main()
{
	Int obj(3);
	string stringValue = obj; // Called conversion opeartor Compile type casting
	obj = 100; // Called conversion constructor
	string str2 = static_cast<string>(obj);
	obj = static_cast<Int>(100);

}*/




// (3) static_cast is more restrictive than c-Style cast.

 // Example: char * to int * allowed in C-Style but not with static_cast.



/*int main()
{
	char c; // 1 Byte
	
	int *p = (int*)(&c); // 4 Byte memory location
	
	*p = 10; // Pass at compile time but failed at run time
	        // (that's wht it is dangerous)
	
 int *p1 = static_cast<int*>(&c);// Failed at compile time, because bot compatible
 
 // error: invalid static_cast from type ‘char*’ to type ‘int*’
}*/




//(4) static_cast avoid cast from derived to private base pointer


/*class Base{};

class Derived: private Base {};

int main()
{
   Derived d1;

   Base *b = (Base*)&d1; // Allowed at compile-time
   
   Base *bp = static_cast<Base*>(&d1); // Not allowed at compile time
   
   return 0;
   
   // error: ‘Base’ is an inaccessible base of ‘Derived’
}*/



//==>> (5) use for all upcaste but never use for confused down cast*/



/*class Base 
{
public:
	virtual void fun()
	{
		cout<<"In Base class"<<endl;
	}
};

class Derived1: public Base 
{
public:
	void fun()
	{
	cout<<"In Derived1 class"<<endl;
	}
};


class Derived2 : public Base 
{
public:
	void fun()
	{
	cout<<"In Derived2 class"<<endl;
	}
};

int main()
{
   
 Derived1 d1;
 Derived2 d2;
 Base ba;

 Base *bp1 = static_cast<Base*>(&d1);
 Base *bp2 = static_cast<Base*>(&d2);
 
 //Derived1 *db = static_cast<Derived1*>(&ba); // Allowed but printing base class fun()
 // db->fun();

 bp1->fun();
 bp2->fun();
 
 cout<<"Sizeof class Base = "<<sizeof(Base)<<endl;
 cout<<"Sizeof class Derived1 = "<<sizeof(Derived1)<<endl;
 cout<<"Sizeof class Derived2 = "<<sizeof(Derived2)<<endl;


}*/



//==> (6) static_cast should be prefered when converting to void* OR from void

/*

int main()
{
	int value = 01;

	void *v = static_cast<void*>(&value);
	
//	/cout<<"Value of v = "<< *v <<endl;
	
	int *ip = static_cast<int*>(v);
	
	cout<<"Value of ip = "<< *ip <<endl;
}
*/





/*
dynamic_cast --> dynamic_cast<new_type>(expression)

=>  which safely convert from pointer(or reference) to a base type to a pointer(or reference) to derived type.
=> Dynamic_cast is used at run time to find out correct down cast.
=> Note:- Need at least one virtual function in base class.
=> Note:- If cast is successful, dynamic cast return a value of type new type.
=> Note:- If cast fails and new type is a pointer type, it return a null pointer of that type
=> Note:- If the cast fails and new type is a reference type, it throws an exception
           that matches a handler of type std:bad_cast.
*/

/*class Base
{
public:
	virtual void print()
	{
		cout<< "Base "<<endl;
	}
};

class Derived1 : public Base
{
public:
	void print()
	{
		cout<<"Derived1 "<<endl;
	}
};
class Derived2 : public Base
{
public:
	void print()
	{
		cout<<"Derived2 "<<endl;
	}
};



int main()
{
	Derived1 d1;

	Base *bp = dynamic_cast<Base*>(&d1);
	if(bp)
		bp->print(); // o/p Derived1
	
	Derived2 *d2 = dynamic_cast<Derived2*>(bp);
	if(d2)
	{
		d2->print();
	}
	else
	{
		cout<<"D2 is null"<<endl; // o/p D2 is null
	}

	Derived1 *d11 = dynamic_cast<Derived1*>(bp);
	if(d11)
	{
		d11->print(); // o/p Derived1
	}
	else
	{
		cout<<"D2 is null"<<endl;
	}
}*/





// reinterpret_cast --> Can be used to convert a pointer to an object to an unrelated object type.

// (1) => It can perform dangerous conversion because it can typecast any pointer to any other pointer.*/


/*class Mango
{
public:
	void eatMango()
	{
		cout<<"In Mango class"<<endl;
	}
};


class Banana
{
public:
	void eatBanana() // Compile changes like this void eatBnana(const Bnana *this, int a, int b)
	{
		cout<<"In Banana class"<<endl;
	}
};


int main()
{
	Banana *banana = new Banana();
	Mango *mango = new Mango();
	Banana *newBanana = reinterpret_cast<Banana*>(mango);
	newBanana->eatBanana();  // o/p In Banana class

}*/



// ==> (2) It is used when you want to work with bits

/*struct Demo
{
	int x;
	int y;
	char c;
	bool b;
};

int main()
{
	Demo obj;
	obj.x = 12;
	obj.y = 30;
	obj.c = 'm';
	obj.b = true;

	int *p = reinterpret_cast<int*>(&obj);
	cout<< *p <<endl; // 12
	++p;
	cout<<*p <<endl; // 30
	++p;
	char *c = reinterpret_cast<char*>(p);
	cout<<*c<<endl; // m
	++c;
	bool *b = reinterpret_cast<bool*>(c);
	cout<<*b <<endl;
}*/



/*
RTTI -> Run-time type indentification is to provide a standard way for a program to determine
 the type of the object during runtime
*/

/*
const_cast  --> add and remove the contness of the variable
----------------------
const_cast in c++
---------------------
=> The expression const_cast<T>(v) can be used to change the const or
volatile qualifier of pointer and reference.
=> Where T must be a pointer, reference or pointer to member types.

=> When we need to call some 3rd party library where it is
taking variable/ object as not const but not changes that
*/
/*void thirdParty(int *x)
{
	int k = 10;
	cout<< k + *(x) <<endl;
}

int main()
{


const int a = 10;
const int *p = &a;
thirdParty(const_cast<int*>(p));

return 0;

}*/



/*Example of static_cast

class A
{
   
};


class B : public A
{
   
   
};


class B : private A 
{
   
   
};

int main()
{
   B b;
   A *a = (A*)(&b); // Explicit cast 
   A *a2 = static_cast<A*>(&b) ; // static_cast // Error 
   
   
   cout<<"Hello c++" <<endl;
}*/



/*
//Exapmle of Dynamic_cast


class A
{
public:
   virtual void fun()
   {
      cout<<"A::fun()"<<endl;
   }
};


class B : public A
{
public:
   void fun()
   {
      cout<<"B::fun()"<<endl;
   }
   
};


int main()
{
   A a;
   
   B b;
   
   //a.fun();
   //b.fun();
   
   
   A *pA = &a;
   B *pB = &b;
   // pA->fun() ;
   //pB->fun();
   
   pA = &b;
 //  pA->fun();
  // pB = &a; // Error not possible t assign the object of class a in pointer of B class.
   pB = dynamic_cast<B*>(&a); // Compile fine and get a waring (warning: dynamic_cast of ‘A a’ to ‘class B*’ can never succeed)
  // pB->fun(); // We will get the Segmentation fault
   
   pB = dynamic_cast<B*>(&b);  
   
}*/

/*

// EXample of reinterpret_cast

class A
{
public:
   void fun()
   {
      cout<<"A::fun()"<<endl;
   }
};


class B 
{
public:
   void fun()
   {
      cout<<"B::fun()"<<endl;
   }
   
};


int main()
{
   A *a = new A();
   
   B *b = new B();
   
   B *b1 = reinterpret_cast<B*>(a);
   b1->fun();
   
}

*/


/* Storage class in c++
 * 
 * auto 
 * register
 * static and 
 * extern
 * mutable
 * 
 * 
 * */
/*-----------------------------------*/



/*class A
{

 virtual int fun(int a) {};
 virtual int fun1(int a) {};
};

int main()

{
	cout<<"SizeOf "<<sizeof(A)<<endl;
	//cout<<"SizeOf int "<<sizeof(int)<<endl;
}*/


/*
class A
{

};

class B
{
   int i;
};

class C
{
   void foo();
};


class D
{
   virtual void foo();
};

class E
{
   int i ;
   virtual void foo();
};



class F
{
   int i;
   void foo();
};


class G
{
   void foo();
   int i;
   void foo1();
};

class H
{
   int i ;
   virtual void foo();
   virtual void foo1();
};


class I
{
   virtual void foo() = 0;
   virtual void foo1() = 0;
   char ch;
   int i;
   int iq;
};

int main()
{
cout <<"sizeof(class A) : " << sizeof(A) << endl ;
cout <<"sizeof(class B) adding the member int i : " << sizeof(B) << endl ;
cout <<"sizeof(class C) adding the member void foo() : " << sizeof(C) << endl ;
cout <<"sizeof(class D) after making foo virtual : " << sizeof(D) << endl ;
cout <<"sizeof(class E) after adding foo virtual , int : " << sizeof(E) << endl ;
cout <<"sizeof(class F) after adding foo  , int : " << sizeof(F) << endl ;
cout <<"sizeof(class G) after adding foo  , int : " << sizeof(G) << endl ;
cout <<"sizeof(class H) after adding int 2 virtual " << sizeof(H) << endl ;
cout <<"sizeof(class I) after adding int 2 virtual " << sizeof(I) << endl ;
return 0;
}
*/
"***********************************************************************************************************************************"
https://www.geeksforgeeks.org/quiz-corner-gq/

https://www.geeksforgeeks.org/c-programming-multiple-choice-questions/



4/10/18
-----------------------

https://www.learncpp.com/cpp-tutorial/6-11a-references-and-const/


Compiler:
-----------------------
GNU G++ /GCC --> unix and linux 
MinGW   -->> Window
Visual C++ compiler -->> Window 

-----------------------
5/10/18
--------

Standard Template Library (STL)

function template
-------------------
temlate<typename T>

T add(T a, T b)
{

return a + b ;
}

int main()
{
int a = 2;
int b = 3;
cout<<add<int>(a,b)<<endl;

}

--------
Without template implementation of class
--------------------
class Something
{

  int a[2];
  int add()'
   
   Something();
 };
 
Something::Something()
{

cin>>a[0]>>a[1];

}

int Something::add()
{

return a[0] + a[1];
}


int main()
{

Something intsomething;

cout<<intsomething.add()<<endl;
return 0;
}

-------------------
class temlate
--------------------
template<typename T>
class Something
{

  T a[2];
  T add();
  Something();
 };
template<typename T> 
Something<T>::Something()
{

cin>>a[0]>>a[1];

}
template<typename T>
T Something<T>::add()
{

return a[0] + a[1];
}


int main()
{

Something <int> intsomething;

cout<<intsomething.add()<<endl;
return 0;
}

---------------------
What are template??
--> Make your program genric.
    increare program reusability.
  Templates are a feature of the C++ programming language 
  that allows functions and classes
   to operate with generic types.
   
   
(i) function template taking one parameter.
template<type T> T add(T a, T b){}

int main()
{
add<int>(2,4)
} 
 
(ii)Function taking two parameter

template<typename T1, typename T2>
T1 add(T1 a, T2 b)  
   
   
 add<int, float>(4, 6.77);  
   
  
----------------------
Template specilization 
----------------------
Special behaviour of perticular data type called template specialization. 
   (i)function template specilization
   
 template<> void add(int i){}
  
(ii)class template specilization 
 
 template<> 
 class Fun<char>
{

public:
  Fun(char ch){
  cout<<ch "indeed charater"} 
   
 
};
------------------------
C++ Standard Library
------------------------
N Algorithms + M container = N+M implementation.
-----------

Containers
--------------
(i) Sequence containers(array and linked list)
 - array
 - linkedlist
 
(ii) Associative containers(binary tree)
 - set, multiset
 - map, multimap 

(iii) Unordered container (hash table)
- Unordered set/ multiset
- Unorser map/ multimap
-------------------------------
Vector :- Sequencial array

/*Property of vector*/
(i)   Fast insert/ remove at the end o(1)
(ii)  Slow insert/remove at the begining or in the middle o(n)
(iii) Slow search o(n)

Created vector
---------------- 
vector<int> vec;

------------
created Dequeue

deque<int> deq = {4, 6, 7}

deq.push_front(2); // {2, 4, 6, 7}
deq.push_back(3); // // {2, 4, 6, 7, 3}

--------------
List: list is double linkedlist

list<int>mylist = {5, 2, 9}
mylist.push_back(6); // mylist {5, 2, 9, 6} 
mylist.push_front(4); // mylist {4, 5, 2, 9, 6}    

list<int>::iterator itr = find(mylist.begin(), mylist.end(), 2); // itr = 2
mylist.insert(itr, 8);
itr++; // itr -> 9

<*> list is musg slower than vector
Cache love contigues memeory of data.
Each element of list store differnt place in memory.
So, once traves the list you will get alot of cache miss.

mylist.splice(itr, mylist2, itr_1, itr_2)

-----------------
Array container

array<int, 3> a = {3, 4, 5}

a.begin()
a.end()
a.size()
a.swap()

---------------------------
Associative container

Set or Multiset
----------------
Associative container typically represented through binary tree.

Note: set/ multiset : value of the element cannot be modified.

multiset<int> myset;


*it = 10;/ *it is the read only: Error

--------------------------
/*
Map */

No Duplicate key
-----------------
map<char,int>mymap;
mymap.insert (pair<char,int>)('a',100);
mymap.insert (make_pair<char,int>)('z',200);

===============================
Unordered Associative Containers(C++11)

(i)  Unordered Set /Multiset 
(ii) Unordered Map /Multimap 

Note: Unordered Associative Containers implemented using 
 hash teble(array of linkedlist)
 


/* unordered set/
*/

unordered_set<string>myset = {"red", "green", "blue"};
unordered_set<string>::const_iterator itr = myset.find("green")

if(itr != myset.end()) // check

cout<< *itr <<endl;

vector<string> vec = {"purple", "pink"};
myset.insert(vec.begin(), vec.end());

------------------------------------
unordered multiset : unordered set that allows duplicated elements.
unordered map : unordered set of pairs
unordered multimap : unordered map that allows duplicated keys.

Note: Hash collision => performance Degrade

----------------
/*
Associative array
* 
* map and onordered map/

unordered_map<char, string> day = {{'S', "Sunday"}, {'M', "Monday"}};

cout<< day['s'] <<endl; // No range check
cout<< day.at('s') <<endl; // Has range check

----------------------------
Notes about associative array:
(i) Search time : unordered_map, o(1); map, o(log(n));
(ii) Unordered_map may degrade to o(n)
(iii) Can't use multimap and unordered_maltimap, they don't have [] operator


----------------------
Container Adapter
- provide a restricted interface to meet special needs.
- Implemented with fundamental container classes
(1) stack : LIFO, push(),pop(), top();
(2) queue : FIFO, push(), pop(), front(), back();
(3) priority queue : first items 


---------------------------
Iterator
(i)   Random access (vector,deque, array)
(ii)  Bidirectional iterator(list, set/multiset, map/multimap)
(iii) Forward iterator(forward_list)
(iv)  Input iterator
(v)   Output iterator
---------------------
Function Object(functors)


Class X{

public:

void operator(string str)
{
cout<<"Calling functors X with parameter"<<endl;

}

operator string
};

int main()
{

X foo;
foo("Hi")// Calling functors X with parameter

}
=================================================
Stack
---------
#include<iostream>
#include<stack>
using namespace std;
int main()
{
std::stack<int> stack;
stack.push(1)
stack.push(2)
stack.push(3)
stack.push(4)
std::cout<<stack.top()<<std::endl;
}
-----------------
Conversion constructors (C++ only)
=====================
https://www.ibm.com/support/knowledgecenter/en/SSLTBW_2.3.0/com.ibm.zos.v2r3.cbclx01/cplr384.htm
https://www.geeksforgeeks.org/g-fact-35/
=============

Advanced C++ | Conversion Operators
=============
https://www.geeksforgeeks.org/advanced-c-conversion-operators/

============
Assignment operator
-------------

class Test
{
// copy constructors
Test(const Test &t);
// Assignment operator
 Test& operator = (const Test&);
};
Test& Test ::operator = (const Test &t)
{

}
-------------
=================================
Explicit conversion operators (C++11)
------------
https://www.ibm.com/support/knowledgecenter/en/SSLTBW_2.3.0/com.ibm.zos.v2r3.cbclx01/explicit_conversion_operators.htm


Note: - Prefixing the explicit keyword to the constructor prevents the compiler from using that constructor for implicit conversions. 


==============================
Design Pattern
---------------
Creational 
Structural 
Behavioural 

----------------
creational Design pattern
(i)   Prototype --> A fully initialized instance should be copy and clone.  
(ii)  Builder --> Separates object construction from it's represented.
(iii) Singleton --> create singalton object
(iv)  Factory Methods --> Create a object for family

-------------
Structural Design Pattern
(i)  Proxy --> An Object representing another object.
              (Credit card is a proxy for what is in our bank account)
(ii) Decorator --> Add responsibility to object dynamically.
(iii)Facade --> A single class that represent an entire subsystem.
(iv) Adapter --> Match interface of differnt classes
(v)  Flyweight --> A fine-grained instance used for efficient sharing.
                (creating instances for efficent sharing)
---------------------
Behavioural Design Pattern
(i)  Chain of responsibility --> A way of passing a request between a chain of object. 
(ii) Iterator --> Sequentially access the elements of a collection.
(iii) State --> Alter an object behaviour when it's state change.
(iv)  Stategy -->> Encapsulate and algoritham insidea class.
(v)   Observer -->> A way of notifying change to a number of class.
(vi)  Visitor -->> Define a new operation to a class without change.
(vii) Template method --> Refer the exact steps of an algoritham to a subclass.
(viii) Command --> Encapsulate a command request as an object.
 (ix) Memento --> Capture and restore an object internal state.
 (x) Mediator  --> Define simplified communication between classes.
 
 
  
 --------------------------------
 5/6/19 : Daily Learning 
 -------------------------------
 (1)Threading Concepts : - 
 
 
 
 
 

 




int x = 5 ;
const int MAX = 12 ;
int &ref_x1 = x ;
const int &ref_x2 = x ;
 
//Try to modify the pointer (e.g. ptr1) and the pointee value (*ptr1)
const int *ptr1 = &x ;
int *const ptr2 = &x ;
const int * const ptr3 = &x ;
 
//Find which declarations are valid. If invalid, correct the declaration
const int *ptr3 = &MAX ;
int *ptr4 = &MAX ;
 
const int &r1 = ref_x1 ;
int &r2 = ref_x2 ;
 
int *&p_ref1 = ptr1 ;
const int*&p_ref2 = ptr2 






















"************************************************************************************************************************************"

We recommend you use the STAR(R) model when answering questions. This will help you create clarity and structure your response. 
 
Situation
Task
Action
Result
Reflection 



Some of the Know question need to know as a c++ developer.
-----------------------------------------------------------------------
Can you have access specifier inside the namespace ?

-> No, Namespace declarations don’t have access specifiers. (Public or private)

Can a class also be declared inside namespace and defined outside .?

-> yes, 

namespace Harman

{
  class Gbl ;
  
}

class Harman :: Gbl {

public :

void disply() {

cout<<"Display the function inside Harman class"<<std::end;

}  
  
} ; // Class close 


Virtual, final and override in C++ ?

https://www.fluentcpp.com/2020/02/21/virtual-final-and-override-in-cpp/


Function overloading VS function overriding 
https://www.geeksforgeeks.org/function-overloading-vs-function-overriding-in-cpp/


Can have inline virtual function ?

-> No The reason is call to a virtual function is resolved at runtime instead of compile time.
-> Inline function resolved at compile time.


How c++ compiler works.
How C++ Works: Understanding Compilation

https://www.udacity.com/blog/2020/02/c-compilers-explained.html
https://www.toptal.com/c-plus-plus/c-plus-plus-understanding-compilation

Why is C++ source code split into header and source files?



Deep Copy vs Shallow copy ?

http://www.fredosaurus.com/notes-cpp/oop-condestructors/shallowdeepcopy.html

https://www.learncpp.com/cpp-tutorial/shallow-vs-deep-copying/


Destructor cann't be overloaded ?-> Yes




Use of #include” preprocessor c++?

The “#include” preprocessor is responsible for directing the compiler 
that the header file needs to be processed before compilation and includes 
all the necessary data type and function definitions.


Different BW Static library and Dynamic library c++?

https://www.geeksforgeeks.org/difference-between-static-and-shared-libraries/
https://medium.com/@laura.derohan/everything-there-is-to-know-about-c-static-libraries-or-at-least-most-of-it-86c082ee41ff
https://medium.com/@laura.derohan/the-differences-between-static-and-dynamic-libraries-70ef076877b5


(Creating a shared libraries):


ar rc libmylib.a file1.o file2.o 

g++ main.cpp -L libmylib.a -o myProgram 

./myProgram (Executable)



Dynamic:

We use an additional flag for dynamic libraries: ‘-fPIC’ or ‘-fpic’. 
This makes the code in the library position independent. PIC is code that works no matter where it is placed in memory.

gcc -c -fPIC my_file.c

gcc -shared -o libmylib.so my_file.o


export LD_LIBRARY_PATH=.:$LD_LIBRARY_PATH


#Count the number of words, characters, and lines in a file?
https://codeforwin.org/2018/02/c-program-count-characters-words-lines-in-file.html




Can a constructor be private in C++ ?

https://www.geeksforgeeks.org/can-constructor-private-cpp/

https://www.hackerearth.com/practice/notes/make-c-class-whose-object-can-only-be-dynamically-created/




https://www.geeksforgeeks.org/advanced-c-virtual-constructor/
================================================================ >> Need to understand 

What is virtual destructor in C++? Why do we need virtual desturctor?

https://www.interviewsansar.com/cplusplus-virtual-destructor-and-use-of-virtual-destructor/


What is the difference between function overloading and templates?

=> Both function overloading and templates are examples of polymorphism feature of OOP.
 Function overloading is used when multiple functions do similar operations, 
 templates are used when multiple functions do identical operations.


Can we combine c and C++ code?
https://www.oracle.com/technical-resources/articles/it-infrastructure/mixing-c-and-cplusplus.html


Smart Pointers in c++ ?

https://www.geeksforgeeks.org/smart-pointers-cpp/

 
Writing one smart pointer class that works for all types.
https://www.geeksforgeeks.org/smart-pointers-cpp/



How to implement user defined Shared Pointers in C++

https://www.codeproject.com/Articles/15351/Implementing-a-simple-smart-pointer-in-c#:~:text=Let%20us%20write%20the%20SP,()%20%7B%20return%20pData%3B%20%7D%20%7D%3B

https://www.geeksforgeeks.org/how-to-implement-user-defined-shared-pointers-in-c/#:~:text=It%20is%20a%20reference%20counting,of%20the%20object%20is%20called.






Analyzing Core Dumps Using GDB ?

https://betterexplained.com/articles/debugging-with-gdb/

Is the core file created in the User space or Kernel Space ?

Kernel Space VS User space  ?



Run time config :

ulimit 
ulimit -Sc --> Soft Limit
ulimit -Hc ---> Hard limit

/etc/security/limit.conf --> Change the limit. 


http://sourceware.org/gdb/current/onlinedocs/gdb/


https://man7.org/linux/man-pages/man7/signal.7.html

Race condition example ??

mutex_lock() -> learn 
info threads -> 
thread apply all bt --> All thread will see

Print natural number in two thread ?

Is ther any priority set for signals? If multiple crash occurs, do we have multiple core dump files?




















===================Copy Constructor==================================
https://en.cppreference.com/w/cpp/language/copy_constructor


A copy constructor of class T is a non-template constructor whose first parameter is T&‍,
const T&‍, volatile T&‍, or const volatile T&‍, and either there are no other parameters,
 or the rest of the parameters all have default values

Syntax

className::className(const className &)
className::className(const className &) = default (c++11)
className::className(const className &) = delete (c++11)

The copy constructor is called whenever an object is initialized (by direct-initialization or copy-initialization)
from another object of the same type 
(unless overload resolution selects a better match or the call is elided), which includes

Initialization: T a = b; or T a(b);, where b is of type T;
function argument passing: f(a);, where a is of type T and f is void f(T t);
function return: return a; inside a function such as T f(), where a is of type T, which has no move constructor.

========================Copy assignment operator======================
https://en.cppreference.com/w/cpp/language/copy_assignment


A copy assignment operator of class T is a non-template non-static member function
 with the name operator= that takes exactly one parameter of type T, T&, 
const T&, volatile T&, or const volatile T&. For a type to be CopyAssignable,
 it must have a public copy assignment operator

Syntax

ClassName& ClassName::operator=(ClassName)

ClassName& ClassName::operator=(ClassName &)

ClassName& ClassName::operator=(const ClassName &)

ClassName& ClassName::operator=(volatile ClassName &)

ClassName& ClassName::operator=(const volatile ClassName &)


ClassName& ClassName::operator=(const ClassName &) = default (c++11)

ClassName& ClassName::operator=(const ClassName &) = delete  (c++11)

================explicit specifier===========================
https://en.cppreference.com/w/cpp/language/explicit


------------------------------------------------------

Pointer to Array:- Pointer to an array is also known as Array pointer.
We are using the pointer to access the components of the array.
-------------------

Data-type (*variable-name)[size of array];

int (*ptr)[10];

int (*ptr)[10] = NULL; // Pointer to array of ten numbers

Ex :- 

int (*ptr)[5];   // Pointer to interger of five numbers

int fun[5] = {1, 2, 3, 4, 5}


ptr = &array  // Point to whole array of fun

int i = 0;

for (i = 0 ; i < 5 ; i++) {

cout << "Element of the array : " << *(*ptr + i) <<endl;

}
================================
Array of Pointer:- is an array of the pointer variable .
It is also know as pointer array.


Data-type *variable[size of array];

int *ptr[1o];



Ex:- 


int ptr[5] = {1, 2, 3, 4, 5};

int *fun[5];

int i;


for (i = 0 ; i < 5 ; i++) {

fun[i] = &ptr[i];

}


// Printing value using Pointer


for (int i = 0 ; i < ptr ; i++) {

cout << "Print the value of array : " << *(*ptr +i) <<::std::endl;

}

=====================================
// Array of pointer

char *name[] = { 
                "Mukesh",
                "RojarFast",
                "Hanuman"
}

for (int i = 0 ; i < 3 ; i++) {

cout << "Elements are :" << *(name+i) <<::std::endl;

}

==========================

int (*Pointer-to-array)[5];

int *array-point-to-zero-location;
int array-point-to-whole-location[5];


array-point-to-zero-location = Pointer-to-array; // Points to 0th element of the arr. 
    p = arr; 

array-point-to-whole-location = &Pointer-to-array; // Points to the whole array arr. 


========================
int arr[3][4] = {  
                    {10, 11, 12, 13},  
                    {20, 21, 22, 23},  
                    {30, 31, 32, 33}  
                  }; 
  int (*ptr)[4]; 
  ptr = arr; 
  printf("%p %p %p\n", ptr, ptr + 1, ptr + 2); 
  printf("%p %p %p\n", *ptr, *(ptr + 1), *(ptr + 2)); 
  printf("%d %d %d\n", **ptr, *(*(ptr + 1) + 2), *(*(ptr + 2) + 3)); 
  printf("%d %d %d\n", ptr[0][0], ptr[1][2], ptr[2][3]);

=============================================================================


How to make a C++ class whose objects can only be dynamically allocated?

https://www.geeksforgeeks.org/make-class-whose-objects-can-dynamically-allocated/





"***********************************************************************************************************************************"
Virtulal Inheritence :

class A {
public:
    void print() {
        cout << "A" << endl;
    }
};
 
class B : virtual public A {
};
 
class C : virtual public A {
};
 
class D : public B, public C {
};
 
int main() {
    D d;
    d.print();
    return 0;
}


"***********************************************************************************************************************************"
Write a code to count the number of words, characters, and lines in a file in c?
#include <stdio.h>
#include <ctype.h>

int main(int argc, char *argv[]) {
  int words = 0, chars = 0, lines = 0;
  char c;
  FILE *fp;

  if (argc != 2) {
    printf("Usage: %s filename\n", argv[0]);
    return 1;
  }

  fp = fopen(argv[1], "r");
  if (fp == NULL) {
    printf("Error opening file %s\n", argv[1]);
    return 1;
  }

  while ((c = getc(fp)) != EOF) {
    chars++;
    if (isspace(c) || c == '\n') {
      words++;
    }
    if (c == '\n') {
      lines++;
    }
  }

  printf("Words: %d\nCharacters: %d\nLines: %d\n", words, chars, lines);

  fclose(fp);
  return 0;
}

"***********************************************************************************************************************************"
What is difference between in C and C++?

C supports procedural programming paradigm for code development.
C++ supports both procedural and object oriented programming paradigms; 
therefore C++ is also called a hybrid language.

C does not support object oriented programming; therefore it has no support for polymorphism, encapsulation, and inheritance.
Being an object oriented programming language C++ supports polymorphism, encapsulation, and inheritance.


In C (because it is a procedural programming language), data and functions are separate and free entities.
In C++ (when it is used as object oriented programming language), data and functions are encapsulated together in form of an object. 
For creating objects class provides a blueprint of structure of the object.


In C, data are free entities and can be manipulated by outside code.
This is because C does not support information hiding.
In C++, Encapsulation hides the data to ensure that data structures and operators are used as intended.


C, being a procedural programming, it is a function driven language.
While, C++, being an object oriented programming, it is an object driven language.


C does not support function and operator overloading.
C++ supports both function and operator overloading.


C does not allow functions to be defined inside structures.
In C++, functions can be used inside a structure.


C does not have namespace feature.
C++ uses NAMESPACE which avoid name collisions.


Namespace:
A namespace is a declarative region that provides a scope to the identifiers
(the names of types, functions, variables, etc) inside it.
Namespaces are used to organize code into logical groups and to prevent name collisions 
that can occur especially when your code base includes multiple libraries. 

All identifiers at namespace scope are visible to one another without qualification.

Identifiers outside the namespace can access the members by using the fully qualified name for each identifier.


C uses functions for input/output. For example scanf and printf.
C++ uses objects for input output. For example cin and cout.


C does not support reference variables.
C++ supports reference variables.


C has no support for virtual and friend functions.
C++ supports virtual and friend functions.


C provides malloc() and calloc() functions for dynamic memory allocation, and free() for memory de-allocation.
C++ provides new operator for memory allocation and delete operator for memory de-allocation.


C does not provide direct support for error handling (also called exception handling)
C++ provides support for exception handling. 
Exceptions are used for "hard" errors that make the code incorrect.


"***********************************************************************************************************************************"
Why is the size of an empty class not zero in C++?
To give a identification on memory space for the instance created for the class a minimum memory is allocated to the instance.

"***********************************************************************************************************************************"
What are C++ access, specifiers ?
https://www.trytoprogram.com/cplusplus-programming/access-specifiers/
"***********************************************************************************************************************************"
What are the various OOPs concepts in C++?

Class: A blueprint that defines the attributes and behaviors of objects.

Object: An instance of a class that has its own attributes and behaviors.

Inheritance: A mechanism that allows a class to inherit the attributes and behaviors of another class.

Polymorphism: The ability of objects to take on many forms, allowing methods to be defined with the same name but different implementations.

Encapsulation: The concept of hiding the internal details of an object and exposing only the necessary information to the outside world.

Abstraction: The ability to focus on the essential features of an object and ignoring the non-essential details.

Constructor: A special method that is called when an object is created, used to initialize the object's attributes.

Destructor: A special method that is called when an object is destroyed, used to release any resources held by the object.

Access Specifiers: Keywords that control the visibility and accessibility of class members, such as public, private, and protected.

"***********************************************************************************************************************************"
What are the differences between a C++ struct and C++ class ?

A struct in C++ is similar to a class, but with a few key differences:

Member Access: By default, members of a struct have public access, while members of a class have private access.

Inheritance: Classes can inherit from other classes, while structs cannot inherit from other structs or classes.

Functionality: Classes can have member functions, while structs cannot have member functions other than constructors.

Usage: Structs are traditionally used for aggregating data, while classes are used for encapsulating both data and behavior

"***********************************************************************************************************************************"
 What is difference between new and malloc?
 
 new and malloc are both used for dynamically allocating memory in C++ and C respectively, but there are some key differences between them:

Syntax: new is an operator in C++, while malloc is a function in C. The syntax for using new is ptr = new type, where ptr is a pointer to the newly created object and type is the type of object to be created. The syntax for using malloc is ptr = (type*)malloc(size), where ptr is a pointer to the allocated memory, type is the data type, and size is the number of bytes to be allocated.

Initialization: new automatically initializes the memory it allocates, while malloc only allocates the memory and does not initialize it.

Exception Handling: new throws an exception if it fails to allocate memory, while malloc returns a null pointer.

Memory Deallocation: In C++, delete operator is used to deallocate memory allocated using new, while in C free function is used to deallocate memory allocated using malloc.
 "***********************************************************************************************************************************"
What is a namespace?

A namespace is a feature in C++ that provides a way to organize code into logical groups and prevent naming conflicts. 
Namespaces allow you to define a scope for identifiers (such as class, function, and variable names)
so that they can be used without ambiguity. This helps to avoid naming collisions between different code modules, 
which can occur when two or more code modules define identifiers with the same name.

namespace my_namespace {
  int x = 42;
  void foo() { ... }
}


int main() {
  int y = my_namespace::x;
  my_namespace::foo();
}
"***********************************************************************************************************************************"
What is Overriding ?


Overriding in C++ is a mechanism of polymorphism in object-oriented programming,
where a derived class re-implements a virtual function of its base class, 
providing a new implementation for that function. The new implementation 
"overrides" the original implementation provided by the base class.


class Shape {
public:
    virtual void draw() { cout<<"Drawing a shape " <<endl;
};


class Circle : public Shape {
public :
void draw() { cout<<"Drawing Circle"<<endl;
};


int main()
{
Shape *sh = new Circle();
sh.draw(); // Drawing Circle
return 0;
}
"***********************************************************************************************************************************"
How to create .dll in C++ and how to link .dll in your code?

Here are the steps to create a DLL (Dynamic Link Library) in C++ and link it in Linux:


Create the DLL project:
Open a terminal and navigate to the directory where you want to create your project.


Create a file for your DLL code (for example, "mydll.cpp").
Write the code for the DLL:
In the DLL file, you can define functions, classes, and variables that will be exported and available to other programs that link to the DLL.
To export a function or class, you need to use the extern "C" keyword and the __attribute__ ((visibility("default"))) attribute. For example:

#include <iostream>

extern "C" {
  __attribute__ ((visibility("default"))) int add(int a, int b) {
    return a + b;
  }
}


Compile the DLL:
In the terminal, run the following command to compile the DLL code:

g++ -shared -o mydll.so mydll.cpp


This will generate a shared library file (.so) named "mydll.so". 
The -shared option tells the compiler to generate a shared library, 
while the -o option specifies the output file name.


Link the DLL in your code:

Create another file for your main project code (for example, "main.cpp").
To call functions or access variables in the DLL,
you need to include the header file of the DLL (if there is one) 
and use the extern keyword to import the desired symbols. For example:


#include <iostream>

extern int add(int a, int b);

int main() {
  int result = add(1, 2);
  std::cout << "The result is: " << result << std::endl;
  return 0;
}


Compile the main project:
In the terminal, run the following command to compile the main project code and link the DLL:

g++ -o main main.cpp -L. -lmydll


Run the program:
In the terminal, run the following command to run the program
./main
"***********************************************************************************************************************************"
What is overloading?

Overloading in C++ refers to the ability to have multiple functions with the same name
but with different parameters.
These functions are considered overloaded because they perform the same basic task but with different inputs.
When a function is called, the compiler determines the correct function to
use based on the number and type of arguments passed to the function.

For example:

#include <iostream>

using namespace std;

int add(int a, int b) {
  return a + b;
}

double add(double a, double b) {
  return a + b;
}

int main() {
  int result1 = add(1, 2);
  double result2 = add(1.0, 2.0);
  std::cout << "The int result is: " << result1 << std::endl;
  std::cout << "The double result is: " << result2 << std::endl;
  return 0;
}
"***********************************************************************************************************************************"
 How to create and use a reference variable in c++?
 
 A reference variable in C++ is an alias for an existing object.
 It provides a way to access the same object using a different name.
 A reference is created using the & symbol.
 
 
 #include <iostream>

int main() {
  int x = 5;
  int &y = x;  // y is a reference to x
  y = 10;  // changes the value of x to 10
  std::cout << "x: " << x << ", y: " << y << std::endl;
  return 0;
}
 "***********************************************************************************************************************************"
Can you overload a function based only on whether a parameter is a value or a reference?

No, in C++ you cannot overload a function based only on whether a parameter is a value or a reference. 
The type and number of parameters must be different for the functions to be considered overloaded.


void foo(int &x) { /* implementation */ }
void foo(const int &x) { /* implementation */ }
void foo(int &&x) { /* implementation */ }

int main() {
  int a = 1;
  const int b = 2;
  foo(a);  // calls void foo(int &x)
  foo(b);  // calls void foo(const int &x)
  foo(3);  // calls void foo(int &&x)
  return 0;
}
"***********************************************************************************************************************************"
What is difference between function overloading and Operator Overloading?

The main difference between function overloading and operator overloading is that function overloading deals with functions,
while operator overloading deals with operators. Function overloading is based on the number and types of parameters, 
while operator overloading is based on the types and number of operands.


"***********************************************************************************************************************************"
C++ code for  : object + 10
Here is an example of overloading the + operator in C++ to add an object of a user-defined class and an integer:


#include <iostream>

class Sukki {
 public:
  int value;

  Sukki operator + (int i) {
    Sukki result;
    result.value = this->value + i;
    return result;
  }
};

int main() {
  Sukki obj;
  obj.value = 5;
  Sukki result = obj + 10;  // calls obj.operator+(10)
  std::cout << result.value << std::endl;
  return 0;
}
"***********************************************************************************************************************************"
Can we access private data members of a class without using a member or a friend function?


Yes, it is possible using pointers.
Although it’s a loophole in C++, yes it’s possible through pointers.

class Test {
private:
    int data;
 
public:
    Test() { data = 0; }
    int getData() { return data; }
};
 
int main()
{
    Test t;
    int* ptr = (int*)&t;
    *ptr = 10;
    cout << t.getData();
    return 0;
"***********************************************************************************************************************************"
What is the use of inline function?

Inline functions are functions in C++ that are expanded in place, 
instead of being executed as a separate function call. 
The compiler replaces each call to an inline function with a copy of the function's body,
effectively eliminating the overhead of a function call.

Inline functions are useful for improving the performance of small, frequently-called functions.
By eliminating the overhead of a function call, the code can run faster, 
especially when the function is called many times in a loop or in a tight loop.


#include <iostream>

class MyClass {
 public:
  inline int square(int x) { return x * x; }
};

int main() {
  MyClass obj;
  int result = obj.square(5);
  std::cout << result << std::endl;
  return 0;
}
"***********************************************************************************************************************************"
How to access derived class function from base class object without using virtual function?

You can access a derived class function from a base class object without using virtual functions by creating a pointer
to the derived class and casting it to a pointer to the base class.
However, this approach can be dangerous and can lead to undefined behavior.


#include <iostream>

class Base {
 public:
  int value;
};

class Derived : public Base {
 public:
  int getValue() { return value; }
};

int main() {
  Base *ptr = new Derived;
  Derived *d_ptr = static_cast<Derived*>(ptr);
  int result = d_ptr->getValue();
  std::cout << result << std::endl;
  return 0;
}
"***********************************************************************************************************************************"
Distinguish between shallow copy and deep copy in c++ ?

Shallow copy :
In C++, a shallow copy is a copy of an object that only copies the values of its member variables to the new object.
without creating new instances of the objects contained within the original object. 
This means that the new object and the original object will both refer to the same objects,
and any changes made to those objects through either object will be reflected in both.


Deep copy : 
Deep copy, on the other hand, creates new instances of all objects contained within the original object, 
such that the new object and the original object are completely independent of each other.
Any changes made to objects within the new object will not affect the original object, and vice versa.


Here's an example of shallow and deep copy in C++:

#include <iostream>
#include <vector>

class Shallow {
 public:
  std::vector<int> vec;
};

class Deep {
 public:
  Deep(const Deep &d) {
    vec = d.vec;
  }
  std::vector<int> vec;
};

int main() {
  Shallow shallow1;
  shallow1.vec.push_back(10);
  Shallow shallow2 = shallow1;
  shallow2.vec[0] = 20;
  std::cout << "Shallow Copy: " << shallow1.vec[0] << std::endl;

  Deep deep1;
  deep1.vec.push_back(10);
  Deep deep2 = deep1;
  deep2.vec[0] = 20;
  std::cout << "Deep Copy: " << deep1.vec[0] << std::endl;
  return 0;
}

O/P :
Shallow Copy: 20
Deep Copy: 10
"***********************************************************************************************************************************"
 Friend class and function in C++ ?
 
A friend class or function in C++ is a class or function that has been granted access to 
the private and protected members of another class. 
By declaring a class or function as a friend, you allow it to access and modify the internals of the class,
even if those members are private.


Here's an example of using a friend function in C++:

#include <iostream>

class A {
 private:
  int value;
 public:
  A(int val) : value(val) {}
  friend int Add(A &a1, A &a2);
};

int Add(A &a1, A &a2) {
  return a1.value + a2.value;
}

int main() {
  A a1(10), a2(20);
  std::cout << "Sum: " << Add(a1, a2) << std::endl;
  return 0;
}

-----------------------------------------------------------------------------
Friend Class Example : 

#include <iostream>

class A {
 private:
  int value;
 public:
  A(int val) : value(val) {}
  friend class B;
};

class B {
 public:
  int Add(A &a1, A &a2) {
    return a1.value + a2.value;
  }
};

int main() {
  A a1(10), a2(20);
  B b;
  std::cout << "Sum: " << b.Add(a1, a2) << std::endl;
  return 0;
}
 "***********************************************************************************************************************************"
 What is difference between constructor and destructor in c++?
 
 In C++, a constructor is a special member function of a class that is automatically called when an object of that class is created. 
 It's used to initialize the data members of the class and allocate memory for the object. 
 Constructors are usually used to provide default or user-defined values for the object when it is created.
 
 
On the other hand, a destructor is a special member function of a class that
is automatically called when an object of that class goes out of scope or is deleted.
It's used to deallocate memory and release any resources used by the object.
Destructors are usually used to clean up after the object when it is no longer needed.


Example:
#include <iostream>

class A {
 private:
  int value;
 public:
  A(int val) : value(val) {
    std::cout << "A constructor called" << std::endl;
  }
  ~A() {
    std::cout << "A destructor called" << std::endl;
  }
};

int main() {
  A a(10);
  return 0;
}
 "***********************************************************************************************************************************"
How are .h files loaded and linked with their .c files?


In C++, the .h (header) files contain declarations for classes, 
functions, and variables, while the .c (source) files contain their definitions. 
The header files are used to make these declarations available to other parts of the program,
while the source files are compiled to produce the object code that is linked to form the final executable.

The process of linking the header files with their source files is usually done through the use of #include directives in the source files.
"***********************************************************************************************************************************"
What Is Inheritance c++?

Inheritance is a mechanism in C++ that allows you to create a new class (the derived class) based on an existing class (the base class).
The derived class inherits all members (data members and member functions) of the base class, 
and can add its own members to those inherited from the base class.


There are several types of inheritance in C++:

Single inheritance: A derived class inherits members from a single base class.

#include <iostream>

class Base {
  public:
    int x;
};

class Derived : public Base {
  public:
    int y;
};

int main() {
    Derived d;
    d.x = 10;
    d.y = 20;

    std::cout << "d.x = " << d.x << std::endl;
    std::cout << "d.y = " << d.y << std::endl;

    return 0;
}



Multiple inheritance: A derived class inherits members from multiple base classes.

#include <iostream>

class Base1 {
  public:
    int x;
};

class Base2 {
  public:
    int y;
};

class Derived : public Base1, public Base2 {
  public:
    int z;
};

int main() {
    Derived d;
    d.x = 10;
    d.y = 20;
    d.z = 30;

    std::cout << "d.x = " << d.x << std::endl;
    std::cout << "d.y = " << d.y << std::endl;
    std::cout << "d.z = " << d.z << std::endl;

    return 0;
}


Hierarchical inheritance: Multiple derived classes inherit members from a single base class.


#include <iostream>

class Base {
  public:
    int x;
};

class Derived1 : public Base {
  public:
    int y;
};

class Derived2 : public Base {
  public:
    int z;
};

int main() {
    Derived1 d1;
    d1.x = 10;
    d1.y = 20;

    Derived2 d2;
    d2.x = 30;
    d2.z = 40;

    std::cout << "d1.x = " << d1.x << std::endl;
    std::cout << "d1.y = " << d1.y << std::endl;

    std::cout << "d2.x = " << d2.x << std::endl;
    std::cout << "d2.z = " << d2.z << std::endl;

    return 0;
}



Multi-level inheritance: A derived class inherits members from a base class, which in turn inherits members from another base class.

#include <iostream>

class Base {
  public:
    int x;
};

class Derived1 : public Base {
  public:
    int y;
};

class Derived2 : public Derived1 {
  public:
    int z;
};

int main() {
    Derived2 d2;
    d2.x = 10;
    d2.y = 20;
    d2.z = 30;

    std::cout << "d2.x = " << d2.x << std::endl;
    std::cout << "d2.y = " << d2.y << std::endl;
    std::cout << "d2.z = " << d2.z << std::endl;

    return 0;
}


Hybrid inheritance: A combination of two or more of the above inheritance types.


Virtual inheretence :
Virtual inheritance is a mechanism in C++ which helps to resolve ambiguity
when multiple classes have a common base class. Here's an example to explain virtual inheritance in C++:

#include <iostream>

class Base {
  public:
    int x;
};

class Derived1 : virtual public Base {
  public:
    int y;
};

class Derived2 : virtual public Base {
  public:
    int z;
};

class Derived3 : public Derived1, public Derived2 {
  public:
    int w;
};

int main() {
    Derived3 d;
    d.x = 10;
    d.y = 20;
    d.z = 30;
    d.w = 40;

    std::cout << "d.x = " << d.x << std::endl;
    std::cout << "d.y = " << d.y << std::endl;
    std::cout << "d.z = " << d.z << std::endl;
    std::cout << "d.w = " << d.w << std::endl;

    return 0;
}



Public inheritance: Members of the base class are accessible in the derived class as public members.

Protected inheritance: Members of the base class are accessible in the derived class as protected members.

Private inheritance : Members of the base class are accessible in the derived class as private members.


"***********************************************************************************************************************************"

What is “this” pointer in c++?



*****************************************************************************************
=========================================================================================
We recommend you use the STAR(R) model when answering questions.
This will help you create clarity and structure your response. 
 
Situation
Task
Action
Result
Reflection 



Some of the Know question need to know as a c++ developer.
-----------------------------------------------------------------------
Can you have access specifier inside the namespace ?

-> No, Namespace declarations don’t have access specifiers. (Public or private)

Can a class also be declared inside namespace and defined outside .?

-> yes, 

namespace Harman

{
  class Gbl ;
  
}

class Harman :: Gbl {

public :

void disply() {

cout<<"Display the function inside Harman class"<<std::end;

}  
  
} ; // Class close 


Virtual, final and override in C++ ?

https://www.fluentcpp.com/2020/02/21/virtual-final-and-override-in-cpp/


Function overloading VS function overriding 
https://www.geeksforgeeks.org/function-overloading-vs-function-overriding-in-cpp/


Can have inline virtual function ?

-> No The reason is call to a virtual function is resolved at runtime instead of compile time.
-> Inline function resolved at compile time.


How c++ compiler works.
How C++ Works: Understanding Compilation

https://www.udacity.com/blog/2020/02/c-compilers-explained.html
https://www.toptal.com/c-plus-plus/c-plus-plus-understanding-compilation

Why is C++ source code split into header and source files?



Deep Copy vs Shallow copy ?

http://www.fredosaurus.com/notes-cpp/oop-condestructors/shallowdeepcopy.html

https://www.learncpp.com/cpp-tutorial/shallow-vs-deep-copying/


Destructor cann't be overloaded ?-> Yes




Use of #include” preprocessor c++?

The “#include” preprocessor is responsible for directing the compiler 
that the header file needs to be processed before compilation and includes 
all the necessary data type and function definitions.


Different BW Static library and Dynamic library c++?

https://www.geeksforgeeks.org/difference-between-static-and-shared-libraries/
https://medium.com/@laura.derohan/everything-there-is-to-know-about-c-static-libraries-or-at-least-most-of-it-86c082ee41ff
https://medium.com/@laura.derohan/the-differences-between-static-and-dynamic-libraries-70ef076877b5


(Creating a shared libraries):


ar rc libmylib.a file1.o file2.o 

g++ main.cpp -L libmylib.a -o myProgram 

./myProgram (Executable)



Dynamic:

We use an additional flag for dynamic libraries: ‘-fPIC’ or ‘-fpic’. 
This makes the code in the library position independent. PIC is code that works no matter where it is placed in memory.

gcc -c -fPIC my_file.c

gcc -shared -o libmylib.so my_file.o


export LD_LIBRARY_PATH=.:$LD_LIBRARY_PATH


#Count the number of words, characters, and lines in a file?
https://codeforwin.org/2018/02/c-program-count-characters-words-lines-in-file.html




Can a constructor be private in C++ ?

https://www.geeksforgeeks.org/can-constructor-private-cpp/

https://www.hackerearth.com/practice/notes/make-c-class-whose-object-can-only-be-dynamically-created/




https://www.geeksforgeeks.org/advanced-c-virtual-constructor/
================================================================ >> Need to understand 

What is virtual destructor in C++? Why do we need virtual desturctor?

https://www.interviewsansar.com/cplusplus-virtual-destructor-and-use-of-virtual-destructor/


What is the difference between function overloading and templates?

=> Both function overloading and templates are examples of polymorphism feature of OOP.
 Function overloading is used when multiple functions do similar operations, 
 templates are used when multiple functions do identical operations.


Can we combine c and C++ code?
https://www.oracle.com/technical-resources/articles/it-infrastructure/mixing-c-and-cplusplus.html


Smart Pointers in c++ ?

https://www.geeksforgeeks.org/smart-pointers-cpp/

 
Writing one smart pointer class that works for all types.
https://www.geeksforgeeks.org/smart-pointers-cpp/



How to implement user defined Shared Pointers in C++

https://www.codeproject.com/Articles/15351/Implementing-a-simple-smart-pointer-in-c#:~:text=Let%20us%20write%20the%20SP,()%20%7B%20return%20pData%3B%20%7D%20%7D%3B

https://www.geeksforgeeks.org/how-to-implement-user-defined-shared-pointers-in-c/#:~:text=It%20is%20a%20reference%20counting,of%20the%20object%20is%20called.

Difference between C structures and C++ structures?
https://www.geeksforgeeks.org/difference-c-structures-c-structures/


Structure Member Alignment, Padding and Data Packing
https://www.geeksforgeeks.org/structure-member-alignment-padding-and-data-packing/


How to avoid Structure Padding in C?

https://www.geeksforgeeks.org/how-to-avoid-structure-padding-in-c/






===================Copy Constructor==================================
https://en.cppreference.com/w/cpp/language/copy_constructor


A copy constructor of class T is a non-template constructor whose first parameter is T&‍,
const T&‍, volatile T&‍, or const volatile T&‍, and either there are no other parameters,
 or the rest of the parameters all have default values

Syntax

className::className(const className &)
className::className(const className &) = default (c++11)
className::className(const className &) = delete (c++11)

The copy constructor is called whenever an object is initialized (by direct-initialization or copy-initialization)
from another object of the same type 
(unless overload resolution selects a better match or the call is elided), which includes

Initialization: T a = b; or T a(b);, where b is of type T;
function argument passing: f(a);, where a is of type T and f is void f(T t);
function return: return a; inside a function such as T f(), where a is of type T, which has no move constructor.

========================Copy assignment operator======================
https://en.cppreference.com/w/cpp/language/copy_assignment


A copy assignment operator of class T is a non-template non-static member function
 with the name operator= that takes exactly one parameter of type T, T&, 
const T&, volatile T&, or const volatile T&. For a type to be CopyAssignable,
 it must have a public copy assignment operator

Syntax

ClassName& ClassName::operator=(ClassName)

ClassName& ClassName::operator=(ClassName &)

ClassName& ClassName::operator=(const ClassName &)

ClassName& ClassName::operator=(volatile ClassName &)

ClassName& ClassName::operator=(const volatile ClassName &)


ClassName& ClassName::operator=(const ClassName &) = default (c++11)

ClassName& ClassName::operator=(const ClassName &) = delete  (c++11)

================explicit specifier===========================
https://en.cppreference.com/w/cpp/language/explicit


------------------------------------------------------

Pointer to Array:- Pointer to an array is also known as Array pointer.
We are using the pointer to access the components of the array.
-------------------

Data-type (*variable-name)[size of array];

int (*ptr)[10];

int (*ptr)[10] = NULL; // Pointer to array of ten numbers

Ex :- 

int (*ptr)[5];   // Pointer to interger of five numbers

int fun[5] = {1, 2, 3, 4, 5}


ptr = &array  // Point to whole array of fun

int i = 0;

for (i = 0 ; i < 5 ; i++) {

cout << "Element of the array : " << *(*ptr + i) <<endl;

}
================================
Array of Pointer:- is an array of the pointer variable .
It is also know as pointer array.


Data-type *variable[size of array];

int *ptr[1o];



Ex:- 


int ptr[5] = {1, 2, 3, 4, 5};

int *fun[5];

int i;


for (i = 0 ; i < 5 ; i++) {

fun[i] = &ptr[i];

}


// Printing value using Pointer


for (int i = 0 ; i < ptr ; i++) {

cout << "Print the value of array : " << *(*ptr +i) <<::std::endl;

}

=====================================
// Array of pointer

char *name[] = { 
                "Mukesh",
                "RojarFast",
                "Hanuman"
}

for (int i = 0 ; i < 3 ; i++) {

cout << "Elements are :" << *(name+i) <<::std::endl;

}

==========================

int (*Pointer-to-array)[5];

int *array-point-to-zero-location;
int array-point-to-whole-location[5];


array-point-to-zero-location = Pointer-to-array; // Points to 0th element of the arr. 
    p = arr; 

array-point-to-whole-location = &Pointer-to-array; // Points to the whole array arr. 


========================
int arr[3][4] = {  
                    {10, 11, 12, 13},  
                    {20, 21, 22, 23},  
                    {30, 31, 32, 33}  
                  }; 
  int (*ptr)[4]; 
  ptr = arr; 
  printf("%p %p %p\n", ptr, ptr + 1, ptr + 2); 
  printf("%p %p %p\n", *ptr, *(ptr + 1), *(ptr + 2)); 
  printf("%d %d %d\n", **ptr, *(*(ptr + 1) + 2), *(*(ptr + 2) + 3)); 
  printf("%d %d %d\n", ptr[0][0], ptr[1][2], ptr[2][3]);

===============================================================================================
***********************************************************************************************
===============================================================================================

4/10/18
-----------------------

https://www.learncpp.com/cpp-tutorial/6-11a-references-and-const/


Compiler:
-----------------------
GNU G++ /GCC --> unix and linux 
MinGW   -->> Window
Visual C++ compiler -->> Window 

-----------------------
5/10/18
--------

Standard Template Library (STL)

function template
-------------------
temlate<typename T>

T add(T a, T b)
{

return a + b ;
}

int main()
{
int a = 2;
int b = 3;
cout<<add<int>(a,b)<<endl;

}

--------
Without template implementation of class
--------------------
class Something
{

  int a[2];
  int add()'
   
   Something();
 };
 
Something::Something()
{

cin>>a[0]>>a[1];

}

int Something::add()
{

return a[0] + a[1];
}


int main()
{

Something intsomething;

cout<<intsomething.add()<<endl;
return 0;
}

-------------------
class temlate
--------------------
template<typename T>
class Something
{

  T a[2];
  T add();
  Something();
 };
template<typename T> 
Something<T>::Something()
{

cin>>a[0]>>a[1];

}
template<typename T>
T Something<T>::add()
{

return a[0] + a[1];
}


int main()
{

Something <int> intsomething;

cout<<intsomething.add()<<endl;
return 0;
}

---------------------
What are template??
--> Make your program genric.
    increare program reusability.
  Templates are a feature of the C++ programming language 
  that allows functions and classes
   to operate with generic types.
   
   
(i) function template taking one parameter.
template<type T> T add(T a, T b){}

int main()
{
add<int>(2,4)
} 
 
(ii)Function taking two parameter

template<typename T1, typename T2>
T1 add(T1 a, T2 b)  
   
   
 add<int, float>(4, 6.77);  
   
  
----------------------
Template specilization 
----------------------
Special behaviour of perticular data type called template specialization. 
   (i)function template specilization
   
 template<> void add(int i){}
  
(ii)class template specilization 
 
 template<> 
 class Fun<char>
{

public:
  Fun(char ch){
  cout<<ch "indeed charater"} 
   
 
};
------------------------
C++ Standard Library
------------------------
N Algorithms + M container = N+M implementation.
-----------

Containers
--------------
(i) Sequence containers(array and linked list)
 - array
 - linkedlist
 
(ii) Associative containers(binary tree)
 - set, multiset
 - map, multimap 

(iii) Unordered container (hash table)
- Unordered set/ multiset
- Unorser map/ multimap
-------------------------------
Vector :- Sequencial array

/*Property of vector*/
(i)   Fast insert/ remove at the end o(1)
(ii)  Slow insert/remove at the begining or in the middle o(n)
(iii) Slow search o(n)

Created vector
---------------- 
vector<int> vec;

------------
created Dequeue

deque<int> deq = {4, 6, 7}

deq.push_front(2); // {2, 4, 6, 7}
deq.push_back(3); // // {2, 4, 6, 7, 3}

--------------
List: list is double linkedlist

list<int>mylist = {5, 2, 9}
mylist.push_back(6); // mylist {5, 2, 9, 6} 
mylist.push_front(4); // mylist {4, 5, 2, 9, 6}    

list<int>::iterator itr = find(mylist.begin(), mylist.end(), 2); // itr = 2
mylist.insert(itr, 8);
itr++; // itr -> 9

<*> list is musg slower than vector
Cache love contigues memeory of data.
Each element of list store differnt place in memory.
So, once traves the list you will get alot of cache miss.

mylist.splice(itr, mylist2, itr_1, itr_2)

-----------------
Array container

array<int, 3> a = {3, 4, 5}

a.begin()
a.end()
a.size()
a.swap()

---------------------------
Associative container

Set or Multiset
----------------
Associative container typically represented through binary tree.

Note: set/ multiset : value of the element cannot be modified.

multiset<int> myset;


*it = 10;/ *it is the read only: Error

--------------------------
/*
Map */

No Duplicate key
-----------------
map<char,int>mymap;
mymap.insert (pair<char,int>)('a',100);
mymap.insert (make_pair<char,int>)('z',200);

===============================
Unordered Associative Containers(C++11)

(i)  Unordered Set /Multiset 
(ii) Unordered Map /Multimap 

Note: Unordered Associative Containers implemented using 
 hash teble(array of linkedlist)
 


/* unordered set/
*/

unordered_set<string>myset = {"red", "green", "blue"};
unordered_set<string>::const_iterator itr = myset.find("green")

if(itr != myset.end()) // check

cout<< *itr <<endl;

vector<string> vec = {"purple", "pink"};
myset.insert(vec.begin(), vec.end());

------------------------------------
unordered multiset : unordered set that allows duplicated elements.
unordered map : unordered set of pairs
unordered multimap : unordered map that allows duplicated keys.

Note: Hash collision => performance Degrade

----------------
/*
Associative array
* 
* map and onordered map/

unordered_map<char, string> day = {{'S', "Sunday"}, {'M', "Monday"}};

cout<< day['s'] <<endl; // No range check
cout<< day.at('s') <<endl; // Has range check

----------------------------
Notes about associative array:
(i) Search time : unordered_map, o(1); map, o(log(n));
(ii) Unordered_map may degrade to o(n)
(iii) Can't use multimap and unordered_maltimap, they don't have [] operator


----------------------
Container Adapter
- provide a restricted interface to meet special needs.
- Implemented with fundamental container classes
(1) stack : LIFO, push(),pop(), top();
(2) queue : FIFO, push(), pop(), front(), back();
(3) priority queue : first items 


---------------------------
Iterator
(i)   Random access (vector,deque, array)
(ii)  Bidirectional iterator(list, set/multiset, map/multimap)
(iii) Forward iterator(forward_list)
(iv)  Input iterator
(v)   Output iterator
---------------------
Function Object(functors)


Class X{

public:

void operator(string str)
{
cout<<"Calling functors X with parameter"<<endl;

}

operator string
};

int main()
{

X foo;
foo("Hi")// Calling functors X with parameter

}
=================================================
Stack
---------
#include<iostream>
#include<stack>
using namespace std;
int main()
{
std::stack<int> stack;
stack.push(1)
stack.push(2)
stack.push(3)
stack.push(4)
std::cout<<stack.top()<<std::endl;
}
-----------------
Conversion constructors (C++ only)
=====================
https://www.ibm.com/support/knowledgecenter/en/SSLTBW_2.3.0/com.ibm.zos.v2r3.cbclx01/cplr384.htm
https://www.geeksforgeeks.org/g-fact-35/
=============

Advanced C++ | Conversion Operators
=============
https://www.geeksforgeeks.org/advanced-c-conversion-operators/

============
Assignment operator
-------------

class Test
{
// copy constructors
Test(const Test &t);
// Assignment operator
 Test& operator = (const Test&);
};
Test& Test ::operator = (const Test &t)
{

}
-------------
=================================
Explicit conversion operators (C++11)
------------
https://www.ibm.com/support/knowledgecenter/en/SSLTBW_2.3.0/com.ibm.zos.v2r3.cbclx01/explicit_conversion_operators.htm


Note: - Prefixing the explicit keyword to the constructor prevents the compiler from using that constructor for implicit conversions. 


==============================
Design Pattern
---------------
Creational 
Structural 
Behavioural 

----------------
creational Design pattern
(i)   Prototype --> A fully initialized instance should be copy and clone.  
(ii)  Builder --> Separates object construction from it's represented.
(iii) Singleton --> create singalton object
(iv)  Factory Methods --> Create a object for family
(v) Abstract Factory -> Abstract Factory is classified in the creational design
                        patterns which is all about class/object instantiation.

-------------
Structural Design Pattern
(i)  Proxy --> An Object representing another object.
              (Credit card is a proxy for what is in our bank account)
(ii) Decorator --> Add responsibility to object dynamically.
(iii)Facade --> A single class that represent an entire subsystem.
(iv) Adapter --> Match interface of differnt classes
(v)  Flyweight --> A fine-grained instance used for efficient sharing.
                (creating instances for efficent sharing)
---------------------
Behavioural Design Pattern
(i)  Chain of responsibility --> A way of passing a request between a chain of object. 
(ii) Iterator --> Sequentially access the elements of a collection.
(iii) State --> Alter an object behaviour when it's state change.
(iv)  Stategy -->> Encapsulate and algoritham insidea class.
(v)   Observer -->> A way of notifying change to a number of class.
(vi)  Visitor -->> Define a new operation to a class without change.
(vii) Template method --> Refer the exact steps of an algoritham to a subclass.
(viii) Command --> Encapsulate a command request as an object.
 (ix) Memento --> Capture and restore an object internal state.
 (x) Mediator  --> Define simplified communication between classes.
 
 
  
 --------------------------------
 5/6/19 : Daily Learning 
 -------------------------------
 (1)Threading Concepts : - 
 


int x = 5 ;
const int MAX = 12 ;
int &ref_x1 = x ;
const int &ref_x2 = x ;
 
//Try to modify the pointer (e.g. ptr1) and the pointee value (*ptr1)
const int *ptr1 = &x ;
int *const ptr2 = &x ;
const int * const ptr3 = &x ;
 
//Find which declarations are valid. If invalid, correct the declaration
const int *ptr3 = &MAX ;
int *ptr4 = &MAX ;
 
const int &r1 = ref_x1 ;
int &r2 = ref_x2 ;
 
int *&p_ref1 = ptr1 ;
const int*&p_ref2 = ptr2 
===============================================================================================
***********************************************************************************************
===============================================================================================

Analyzing Core Dumps Using GDB ?

https://betterexplained.com/articles/debugging-with-gdb/

Is the core file created in the User space or Kernel Space ?

Kernel Space VS User space  ?



Run time config :

ulimit 
ulimit -Sc --> Soft Limit
ulimit -Hc ---> Hard limit

/etc/security/limit.conf --> Change the limit. 


http://sourceware.org/gdb/current/onlinedocs/gdb/


https://man7.org/linux/man-pages/man7/signal.7.html

Race condition example ??

mutex_lock() -> learn 
info threads -> 
thread apply all bt --> All thread will see

Print natural number in two thread ?

Is ther any priority set for signals? If multiple crash occurs, do we have multiple core dump files?






















c++_interview_questions.txt
Displaying c++_interview_questions.txt.
